<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åå°ç®¡ç†ç³»ç»Ÿ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, "Microsoft YaHei", sans-serif; }
        body { background-color: #f0f2f5; min-height: 100vh; }

        /* é¡¶éƒ¨å¯¼èˆª */
        header { 
            background: linear-gradient(135deg, #0f6b48 0%, #1a8d5f 100%);
            color: #fff; 
            padding: 15px 30px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 { font-size: 20px; font-weight: bold; }
        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .btn-header {
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: 0.3s;
        }
        .btn-header:hover {
            background: rgba(255,255,255,0.3);
        }

        /* ä¸»å®¹å™¨ */
        .container { max-width: 1400px; margin: 20px auto; padding: 0 20px; }

        /* å¡ç‰‡ */
        .card { 
            background: #fff; 
            border-radius: 8px; 
            padding: 25px; 
            margin-bottom: 20px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .card-title { 
            font-size: 18px; 
            color: #0f6b48; 
            border-bottom: 2px solid #f0f2f5; 
            padding-bottom: 10px; 
            margin-bottom: 20px; 
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* é…ç½®è¡¨å• */
        .form-row {
            display: grid;
            grid-template-columns: 150px 1fr;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
        }
        .form-label {
            font-weight: bold;
            color: #666;
        }
        .form-input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
        }
        .form-input:focus {
            outline: none;
            border-color: #0f6b48;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* è¡¨æ ¼æ ·å¼ */
        .table-container {
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        thead {
            background: #f8f9fa;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }
        th {
            font-weight: 600;
            color: #495057;
            font-size: 13px;
            text-transform: uppercase;
        }
        td {
            font-size: 14px;
            color: #212529;
        }
        tbody tr:hover {
            background: #f8f9fa;
        }
        .table-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }
        .table-input:focus {
            outline: none;
            border-color: #0f6b48;
        }
        .table-input-small {
            width: 60px;
        }

        /* æŒ‰é’® */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: 0.3s;
        }
        .btn-primary {
            background: #0f6b48;
            color: white;
        }
        .btn-primary:hover {
            background: #0b5539;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background: #c82333;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-success:hover {
            background: #218838;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #5a6268;
        }

        /* å›¾ç‰‡é¢„è§ˆ */
        .img-preview {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
        }

        /* æç¤ºä¿¡æ¯ */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 4px;
            z-index: 1000;
            display: none;
            animation: slideIn 0.3s ease;
        }
        @keyframes slideIn {
            from { transform: translateX(400px); }
            to { transform: translateX(0); }
        }
        .toast.success {
            background: #28a745;
        }
        .toast.error {
            background: #dc3545;
        }

        /* æ“ä½œæŒ‰é’®åˆ— */
        .action-btns {
            display: flex;
            gap: 5px;
        }

        /* æ‰¹é‡å¯¼å…¥/å¯¼å‡º */
        .bulk-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        /* æ–‡ä»¶ä¸Šä¼  */
        .file-input {
            display: none;
        }

        /* å¸®åŠ©æç¤º */
        .help-text {
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
        }

        /* ===== å“åº”å¼è®¾è®¡ - æ‰‹æœºç«¯é€‚é… ===== */
        @media (max-width: 768px) {
            body {
                overflow-x: hidden;
            }
            
            /* é¡¶éƒ¨å¯¼èˆª */
            header {
                flex-direction: column;
                gap: 10px;
                padding: 12px 15px;
            }
            
            h1 {
                font-size: 18px;
            }
            
            .header-actions {
                width: 100%;
                flex-wrap: wrap;
                justify-content: flex-start;
            }
            
            .btn-header {
                padding: 6px 12px;
                font-size: 12px;
            }
            
            /* å®¹å™¨ */
            .container {
                padding: 0 15px;
            }
            
            /* å¡ç‰‡ */
            .card {
                padding: 15px;
                margin-bottom: 15px;
            }
            
            .card-title {
                font-size: 16px;
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            /* è¡¨å• */
            .form-row {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .form-label {
                font-size: 13px;
            }
            
            .form-input {
                font-size: 13px;
            }
            
            /* æ‰¹é‡æ“ä½œæŒ‰é’® */
            .bulk-actions {
                flex-wrap: wrap;
                width: 100%;
                margin-top: 10px;
            }
            
            .bulk-actions .btn {
                flex: 1;
                min-width: 120px;
            }
            
            /* è¡¨æ ¼å®¹å™¨ */
            .table-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            table {
                min-width: 600px;
                font-size: 12px;
            }
            
            th, td {
                padding: 8px 6px;
                font-size: 12px;
            }
            
            th {
                font-size: 11px;
            }
            
            .table-input {
                padding: 4px 6px;
                font-size: 12px;
            }
            
            .img-preview {
                width: 40px;
                height: 40px;
            }
            
            /* æŒ‰é’® */
            .btn {
                padding: 6px 12px;
                font-size: 12px;
            }
            
            .action-btns {
                flex-direction: column;
                gap: 3px;
            }
            
            /* æç¤ºæ¡† */
            .toast {
                right: 10px;
                left: 10px;
                padding: 12px 15px;
                font-size: 13px;
            }
        }
        
        /* è¶…å°å±å¹• */
        @media (max-width: 480px) {
            h1 {
                font-size: 16px;
            }
            
            .card {
                padding: 12px;
            }
            
            .card-title {
                font-size: 15px;
            }
            
            table {
                min-width: 500px;
                font-size: 11px;
            }
            
            th, td {
                padding: 6px 4px;
            }
            
            .bulk-actions .btn {
                width: 100%;
            }
            
            .btn-header {
                font-size: 11px;
                padding: 5px 10px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>ğŸ½ï¸ é¤å…çœ‹æ¿åå°ç®¡ç†ç³»ç»Ÿ</h1>
        <div class="header-actions">
            <button class="btn-header" onclick="exportAllData()">ğŸ“¥ å¯¼å‡ºæ‰€æœ‰æ•°æ®</button>
            <button class="btn-header" onclick="resetToken()">ğŸ”‘ é‡ç½®å¯†é’¥</button>
            <a href="/" target="_blank" class="btn-header" style="text-decoration: none;">æŸ¥çœ‹å‰å° â†’</a>
        </div>
    </header>

    <div class="container">
        <!-- å…¨å±€é…ç½® -->
        <div class="card">
            <div class="card-title">âš™ï¸ å…¨å±€é…ç½®</div>
            
            <div class="form-row">
                <label class="form-label">é¡µé¢æ ‡é¢˜</label>
                <input type="text" class="form-input" id="config-title" placeholder="ä¾‹å¦‚ï¼šåŸƒåŠå°¼ç½—æ²³é¤å…å…¨æ¥è§¦">
            </div>
            
            <div class="form-row">
                <label class="form-label">æ—¥æœŸ/ä½ç½®</label>
                <div style="flex: 1;">
                    <input type="text" class="form-input" id="config-date" placeholder="ä¾‹å¦‚ï¼š2025-12-08 åˆé¤">
                    <div class="checkbox-group" style="margin-top: 8px;">
                        <input type="checkbox" id="config-auto-date">
                        <label for="config-auto-date">è‡ªåŠ¨ç”Ÿæˆå½“å‰æ—¥æœŸ</label>
                    </div>
                    <div class="help-text">å‹¾é€‰åå°†è‡ªåŠ¨æ˜¾ç¤ºå½“å‰æ—¥æœŸå’Œæ—¶é—´æ®µï¼ˆåˆé¤/æ™šé¤ï¼‰</div>
                </div>
            </div>
            
            <button class="btn btn-primary" onclick="saveConfig()">ğŸ’¾ ä¿å­˜é…ç½®</button>
        </div>

        <!-- èœå“ç®¡ç† -->
        <div class="card">
            <div class="card-title">
                <span>ğŸ½ï¸ èœå“ç®¡ç†</span>
                <div class="bulk-actions">
                    <button class="btn btn-success" onclick="addDish()">â• æ–°å¢èœå“</button>
                    <button class="btn btn-secondary" onclick="importDishes()">ğŸ“¤ æ‰¹é‡å¯¼å…¥</button>
                    <button class="btn" style="background:#17a2b8; color:white;" onclick="openSmartImport()">ğŸ“‹ æ™ºèƒ½å¯¼å…¥èœå•</button>
                    <button class="btn btn-secondary" onclick="exportDishes()">ğŸ“¥ å¯¼å‡ºè¡¨æ ¼</button>
                </div>
            </div>
            
            <div class="table-container">
                <table id="dishes-table">
                    <thead>
                        <tr>
                            <th style="width: 50px;">ID</th>
                            <th>èœå“åç§°</th>
                            <th>å¨å¸ˆ</th>
                            <th style="width: 80px;">ç‚¹èµæ•°</th>
                            <th style="width: 80px;">è¸©æ•°</th>
                            <th style="width: 120px;">æ“ä½œ</th>
                        </tr>
                    </thead>
                    <tbody id="dishes-tbody">
                        <tr><td colspan="6" style="text-align: center; color: #999;">åŠ è½½ä¸­...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- å¨å¸ˆç®¡ç† -->
        <div class="card">
            <div class="card-title">
                <span>ğŸ‘¨â€ğŸ³ å¨å¸ˆç®¡ç†</span>
                <div class="bulk-actions">
                    <button class="btn btn-success" onclick="addChef()">â• æ–°å¢å¨å¸ˆ</button>
                    <button class="btn btn-secondary" onclick="importChefs()">ğŸ“¤ æ‰¹é‡å¯¼å…¥</button>
                    <button class="btn btn-secondary" onclick="exportChefs()">ğŸ“¥ å¯¼å‡ºè¡¨æ ¼</button>
                </div>
            </div>
            
            <div class="table-container">
                <table id="chefs-table">
                    <thead>
                        <tr>
                            <th style="width: 50px;">ID</th>
                            <th style="width: 60px;">ç…§ç‰‡</th>
                            <th>å§“å</th>
                            <th>èŒä½</th>
                            <th>ç®€ä»‹</th>
                            <th style="width: 70px;">æ—¥æ¦œ</th>
                            <th style="width: 70px;">æœˆæ¦œ</th>
                            <th style="width: 70px;">æœˆç¥¨</th>
                            <th style="width: 120px;">æ“ä½œ</th>
                        </tr>
                    </thead>
                    <tbody id="chefs-tbody">
                        <tr><td colspan="9" style="text-align: center; color: #999;">åŠ è½½ä¸­...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>
        <div id="smart-import-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:2000; align-items:center; justify-content:center;">
        <div style="background:white; width:90%; max-width:800px; max-height:90vh; border-radius:8px; display:flex; flex-direction:column; overflow:hidden;">
            <div style="padding:15px 20px; border-bottom:1px solid #eee; display:flex; justify-content:space-between; align-items:center;">
                <h3 style="margin:0;">ğŸ“‹ æ™ºèƒ½èœå•è¯†åˆ«</h3>
                <span onclick="document.getElementById('smart-import-modal').style.display='none'" style="cursor:pointer; font-size:24px;">&times;</span>
            </div>
            <div style="padding:20px; overflow-y:auto; flex:1;">
                <div style="background:#fff3cd; color:#856404; padding:10px; border-radius:4px; margin-bottom:15px; font-size:13px;">
                    ğŸ’¡ æç¤ºï¼šç›´æ¥ç²˜è´´å¾®ä¿¡ç¾¤é‡Œçš„èœå•é€šçŸ¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è¯†åˆ«èœå“å’Œå¯¹åº”å¨å¸ˆã€‚
                </div>
                <textarea id="import-text" style="width:100%; height:150px; padding:10px; border:1px solid #ddd; border-radius:4px; margin-bottom:15px;" placeholder="è¯·ç²˜è´´èœå•æ–‡æœ¬..."></textarea>
                <button class="btn btn-primary" onclick="parseMenuText()" style="width:100%;">ğŸ” å¼€å§‹è§£æ</button>
                
                <div id="import-preview" style="display:none; margin-top:20px; border-top:1px solid #eee; padding-top:20px;">
                    <div style="margin-bottom:10px; font-weight:bold; color:#0f6b48;">é¢„è§ˆå¯¼å…¥ç»“æœ (<span id="preview-count">0</span> é“èœ)</div>
                    <div style="max-height:300px; overflow-y:auto; border:1px solid #eee; border-radius:4px;">
                        <table style="width:100%; border-collapse:collapse;">
                            <thead style="background:#f8f9fa; position:sticky; top:0;">
                                <tr>
                                    <th style="padding:8px; text-align:left;">èœå“åç§°</th>
                                    <th style="padding:8px; text-align:left;">å½’å±å¨å¸ˆ</th>
                                    <th style="padding:8px; text-align:center; width:60px;">çŠ¶æ€</th>
                                </tr>
                            </thead>
                            <tbody id="preview-tbody"></tbody>
                        </table>
                    </div>
                    <div style="margin-top:15px; text-align:right;">
                        <button class="btn btn-secondary" onclick="document.getElementById('smart-import-modal').style.display='none'">å–æ¶ˆ</button>
                        <button class="btn btn-success" onclick="executeImport()">âœ… ç¡®è®¤å¹¶å¯¼å…¥</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- éšè—çš„æ–‡ä»¶ä¸Šä¼ è¾“å…¥ -->
    <input type="file" id="file-input-dishes" class="file-input" accept=".json,.csv" onchange="handleDishesImport(event)">
    <input type="file" id="file-input-chefs" class="file-input" accept=".json,.csv" onchange="handleChefsImport(event)">
    <input type="file" id="file-input-photo" class="file-input" accept="image/*">

    <script>
        let adminToken = localStorage.getItem('admin_token') || '';
        let currentPhotoTarget = null;

        // è·å–è¯·æ±‚å¤´
        function getHeaders() {
            return {
                'Content-Type': 'application/json',
                'x-admin-token': adminToken
            };
        }

        // åˆå§‹åŒ–
        function init() {
            if (!adminToken) {
                promptForToken();
                return;
            }
            loadAll();
        }

        // æç¤ºè¾“å…¥å¯†é’¥
        function promptForToken() {
            const token = prompt('è¯·è¾“å…¥ç®¡ç†å¯†é’¥ï¼ˆé»˜è®¤: demo2024ï¼‰ï¼š', 'demo2024');
            if (token) {
                adminToken = token;
                localStorage.setItem('admin_token', token);
                loadAll();
            } else {
                showToast('éœ€è¦è®¿é—®å¯†é’¥æ‰èƒ½ä½¿ç”¨åå°ç®¡ç†', 'error');
            }
        }

        // åŠ è½½æ‰€æœ‰æ•°æ®
        async function loadAll() {
            try {
                await loadConfig();
                await loadDishes();
                await loadChefs();
            } catch (err) {
                console.error('åŠ è½½å¤±è´¥:', err);
                showToast('åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥', 'error');
            }
        }

        // åŠ è½½é…ç½®
        async function loadConfig() {
            try {
                const res = await fetch('/api/admin/config', { headers: getHeaders() });
                if (!res.ok) throw new Error('è·å–é…ç½®å¤±è´¥');
                const data = await res.json();
                
                document.getElementById('config-title').value = data.config.title || '';
                document.getElementById('config-date').value = data.config.date_location || '';
                document.getElementById('config-auto-date').checked = data.config.auto_date === 1;
            } catch (err) {
                console.error('åŠ è½½é…ç½®å¤±è´¥:', err);
            }
        }

        // ä¿å­˜é…ç½®
        async function saveConfig() {
            const config = {
                title: document.getElementById('config-title').value,
                date_location: document.getElementById('config-date').value,
                auto_date: document.getElementById('config-auto-date').checked
            };

            try {
                const res = await fetch('/api/admin/config', {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify(config)
                });

                if (!res.ok) throw new Error('ä¿å­˜å¤±è´¥');
                showToast('âœ… é…ç½®å·²ä¿å­˜', 'success');
            } catch (err) {
                showToast('ä¿å­˜å¤±è´¥: ' + err.message, 'error');
            }
        }

        // åŠ è½½èœå“
        async function loadDishes() {
            try {
                const res = await fetch('/api/admin/dishes', { headers: getHeaders() });
                if (!res.ok) throw new Error('è·å–èœå“å¤±è´¥');
                const data = await res.json();
                
                renderDishes(data.dishes);
            } catch (err) {
                console.error('åŠ è½½èœå“å¤±è´¥:', err);
                document.getElementById('dishes-tbody').innerHTML = 
                    '<tr><td colspan="6" style="text-align: center; color: red;">åŠ è½½å¤±è´¥</td></tr>';
            }
        }

        // æ¸²æŸ“èœå“è¡¨æ ¼
        function renderDishes(dishes) {
        const tbody = document.getElementById('dishes-tbody');
        
        if (dishes.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #999;">æš‚æ— èœå“</td></tr>';
            return;
        }
    
        // ğŸ‘‡ æ³¨æ„è¿™é‡Œï¼šæ”¹æˆäº† (dish, index)
        tbody.innerHTML = dishes.map((dish, index) => `
            <tr data-id="${dish.id}">
                <td>${index + 1}</td>
                <td><input type="text" class="table-input" value="${dish.name}" onchange="updateDish(${dish.id}, 'name', this.value)"></td>
                <td><input type="text" class="table-input" value="${dish.chef}" onchange="updateDish(${dish.id}, 'chef', this.value)"></td>
                <td><input type="number" class="table-input table-input-small" value="${dish.up_votes}" onchange="updateDish(${dish.id}, 'up_votes', this.value)"></td>
                <td><input type="number" class="table-input table-input-small" value="${dish.down_votes}" onchange="updateDish(${dish.id}, 'down_votes', this.value)"></td>
                <td class="action-btns">
                    <button class="btn btn-danger" onclick="deleteDish(${dish.id})">åˆ é™¤</button>
                </td>
            </tr>
        `).join('');
    }

        // æ›´æ–°èœå“
        async function updateDish(id, field, value) {
            const row = document.querySelector(`#dishes-tbody tr[data-id="${id}"]`);
            const data = {
                name: row.querySelector('input[type="text"]').value,
                chef: row.querySelectorAll('input[type="text"]')[1].value,
                up_votes: parseInt(row.querySelectorAll('input[type="number"]')[0].value) || 0,
                down_votes: parseInt(row.querySelectorAll('input[type="number"]')[1].value) || 0
            };

            try {
                const res = await fetch(`/api/admin/dishes/${id}`, {
                    method: 'PUT',
                    headers: getHeaders(),
                    body: JSON.stringify(data)
                });

                if (!res.ok) throw new Error('æ›´æ–°å¤±è´¥');
                showToast('âœ… å·²æ›´æ–°', 'success');
            } catch (err) {
                showToast('æ›´æ–°å¤±è´¥: ' + err.message, 'error');
            }
        }

        // æ·»åŠ èœå“
        async function addDish() {
            const data = {
                name: 'æ–°èœå“',
                chef: 'æ–°å¨å¸ˆ',
                up_votes: 0,
                down_votes: 0
            };

            try {
                const res = await fetch('/api/admin/dishes', {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify(data)
                });

                if (!res.ok) throw new Error('åˆ›å»ºå¤±è´¥');
                showToast('âœ… å·²æ·»åŠ æ–°èœå“', 'success');
                await loadDishes();
            } catch (err) {
                showToast('æ·»åŠ å¤±è´¥: ' + err.message, 'error');
            }
        }

        // åˆ é™¤èœå“
        async function deleteDish(id) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™é“èœå“å—ï¼Ÿ')) return;

            try {
                const res = await fetch(`/api/admin/dishes/${id}`, {
                    method: 'DELETE',
                    headers: getHeaders()
                });

                if (!res.ok) throw new Error('åˆ é™¤å¤±è´¥');
                showToast('âœ… å·²åˆ é™¤', 'success');
                await loadDishes();
            } catch (err) {
                showToast('åˆ é™¤å¤±è´¥: ' + err.message, 'error');
            }
        }

        // åŠ è½½å¨å¸ˆ
        async function loadChefs() {
            try {
                const res = await fetch('/api/admin/chefs', { headers: getHeaders() });
                if (!res.ok) throw new Error('è·å–å¨å¸ˆå¤±è´¥');
                const data = await res.json();
                
                renderChefs(data.chefs);
            } catch (err) {
                console.error('åŠ è½½å¨å¸ˆå¤±è´¥:', err);
                document.getElementById('chefs-tbody').innerHTML = 
                    '<tr><td colspan="9" style="text-align: center; color: red;">åŠ è½½å¤±è´¥</td></tr>';
            }
        }

        // æ¸²æŸ“å¨å¸ˆè¡¨æ ¼
        function renderChefs(chefs) {
            const tbody = document.getElementById('chefs-tbody');
            
            if (chefs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; color: #999;">æš‚æ— å¨å¸ˆ</td></tr>';
                return;
            }

            tbody.innerHTML = chefs.map(chef => `
                <tr data-id="${chef.id}">
                    <td>${chef.id}</td>
                    <td>
                        <img src="${chef.photo}" class="img-preview" onclick="changePhoto(${chef.id})" title="ç‚¹å‡»æ›´æ¢ç…§ç‰‡">
                    </td>
                    <td><input type="text" class="table-input" value="${chef.name}" onchange="updateChef(${chef.id})"></td>
                    <td><input type="text" class="table-input" value="${chef.role}" onchange="updateChef(${chef.id})"></td>
                    <td><input type="text" class="table-input" value="${chef.description || ''}" onchange="updateChef(${chef.id})"></td>
                    <td><input type="number" class="table-input table-input-small" value="${chef.daily_rank}" onchange="updateChef(${chef.id})"></td>
                    <td><input type="number" class="table-input table-input-small" value="${chef.monthly_rank}" onchange="updateChef(${chef.id})"></td>
                    <td><input type="number" class="table-input table-input-small" value="${chef.monthly_votes}" onchange="updateChef(${chef.id})"></td>
                    <td class="action-btns">
                        <button class="btn btn-danger" onclick="deleteChef(${chef.id})">åˆ é™¤</button>
                    </td>
                </tr>
            `).join('');
        }

        // æ›´æ–°å¨å¸ˆ
        async function updateChef(id) {
            const row = document.querySelector(`#chefs-tbody tr[data-id="${id}"]`);
            const inputs = row.querySelectorAll('input');
            const data = {
                name: inputs[0].value,
                role: inputs[1].value,
                description: inputs[2].value,
                daily_rank: parseInt(inputs[3].value) || 99,
                monthly_rank: parseInt(inputs[4].value) || 99,
                monthly_votes: parseInt(inputs[5].value) || 0,
                photo: row.querySelector('img').src
            };

            try {
                const res = await fetch(`/api/admin/chefs/${id}`, {
                    method: 'PUT',
                    headers: getHeaders(),
                    body: JSON.stringify(data)
                });

                if (!res.ok) throw new Error('æ›´æ–°å¤±è´¥');
                showToast('âœ… å·²æ›´æ–°', 'success');
            } catch (err) {
                showToast('æ›´æ–°å¤±è´¥: ' + err.message, 'error');
            }
        }

        // æ·»åŠ å¨å¸ˆ
        async function addChef() {
            const data = {
                name: 'æ–°å¨å¸ˆ',
                role: 'å¨å¸ˆ',
                photo: 'static/logo.png',
                description: 'è¯·ä¿®æ”¹ç®€ä»‹',
                daily_rank: 99,
                monthly_rank: 99,
                monthly_votes: 0
            };

            try {
                const res = await fetch('/api/admin/chefs', {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify(data)
                });

                if (!res.ok) throw new Error('åˆ›å»ºå¤±è´¥');
                showToast('âœ… å·²æ·»åŠ æ–°å¨å¸ˆ', 'success');
                await loadChefs();
            } catch (err) {
                showToast('æ·»åŠ å¤±è´¥: ' + err.message, 'error');
            }
        }

        // åˆ é™¤å¨å¸ˆ
        async function deleteChef(id) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä½å¨å¸ˆå—ï¼Ÿ')) return;

            try {
                const res = await fetch(`/api/admin/chefs/${id}`, {
                    method: 'DELETE',
                    headers: getHeaders()
                });

                if (!res.ok) throw new Error('åˆ é™¤å¤±è´¥');
                showToast('âœ… å·²åˆ é™¤', 'success');
                await loadChefs();
            } catch (err) {
                showToast('åˆ é™¤å¤±è´¥: ' + err.message, 'error');
            }
        }

        // æ›´æ¢ç…§ç‰‡
        function changePhoto(chefId) {
            currentPhotoTarget = chefId;
            document.getElementById('file-input-photo').click();
        }

        // å¤„ç†ç…§ç‰‡ä¸Šä¼ 
        document.getElementById('file-input-photo').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const formData = new FormData();
            formData.append('file', file);

            try {
                const res = await fetch('/api/upload', {
                    method: 'POST',
                    headers: { 'x-admin-token': adminToken },
                    body: formData
                });

                if (!res.ok) throw new Error('ä¸Šä¼ å¤±è´¥');
                const data = await res.json();

                // æ›´æ–°å›¾ç‰‡
                const row = document.querySelector(`#chefs-tbody tr[data-id="${currentPhotoTarget}"]`);
                row.querySelector('img').src = data.url;

                await updateChef(currentPhotoTarget);
                showToast('âœ… ç…§ç‰‡å·²æ›´æ–°', 'success');
            } catch (err) {
                showToast('ä¸Šä¼ å¤±è´¥: ' + err.message, 'error');
            }

            e.target.value = '';
        });

        // å¯¼å‡ºèœå“
        function exportDishes() {
            fetch('/api/admin/dishes', { headers: getHeaders() })
                .then(res => res.json())
                .then(data => {
                    const csv = dishesToCSV(data.dishes);
                    downloadCSV(csv, 'dishes.csv');
                    showToast('âœ… å·²å¯¼å‡º', 'success');
                });
        }

        // å¯¼å‡ºå¨å¸ˆ
        function exportChefs() {
            fetch('/api/admin/chefs', { headers: getHeaders() })
                .then(res => res.json())
                .then(data => {
                    const csv = chefsToCSV(data.chefs);
                    downloadCSV(csv, 'chefs.csv');
                    showToast('âœ… å·²å¯¼å‡º', 'success');
                });
        }

        // å¯¼å‡ºæ‰€æœ‰æ•°æ®
        async function exportAllData() {
            try {
                const [configRes, dishesRes, chefsRes] = await Promise.all([
                    fetch('/api/admin/config', { headers: getHeaders() }),
                    fetch('/api/admin/dishes', { headers: getHeaders() }),
                    fetch('/api/admin/chefs', { headers: getHeaders() })
                ]);

                const [config, dishes, chefs] = await Promise.all([
                    configRes.json(),
                    dishesRes.json(),
                    chefsRes.json()
                ]);

                const allData = {
                    config: config.config,
                    dishes: dishes.dishes,
                    chefs: chefs.chefs,
                    exported_at: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(allData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `restaurant-data-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);

                showToast('âœ… å·²å¯¼å‡ºæ‰€æœ‰æ•°æ®', 'success');
            } catch (err) {
                showToast('å¯¼å‡ºå¤±è´¥: ' + err.message, 'error');
            }
        }

        // CSV è½¬æ¢
        function dishesToCSV(dishes) {
            const headers = ['ID', 'èœå“åç§°', 'å¨å¸ˆ', 'ç‚¹èµæ•°', 'è¸©æ•°'];
            const rows = dishes.map(d => [d.id, d.name, d.chef, d.up_votes, d.down_votes]);
            return [headers, ...rows].map(row => row.join(',')).join('\n');
        }

        function chefsToCSV(chefs) {
            const headers = ['ID', 'å§“å', 'èŒä½', 'ç®€ä»‹', 'æ—¥æ¦œ', 'æœˆæ¦œ', 'æœˆç¥¨', 'ç…§ç‰‡'];
            const rows = chefs.map(c => [c.id, c.name, c.role, c.description, c.daily_rank, c.monthly_rank, c.monthly_votes, c.photo]);
            return [headers, ...rows].map(row => row.join(',')).join('\n');
        }

        function downloadCSV(csv, filename) {
            const BOM = '\uFEFF';  // UTF-8 BOM
            const blob = new Blob([BOM + csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // æ‰¹é‡å¯¼å…¥ï¼ˆç®€åŒ–ç‰ˆï¼‰
        function importDishes() {
            alert('æ‰¹é‡å¯¼å…¥åŠŸèƒ½ï¼š\nè¯·å‡†å¤‡CSVæ–‡ä»¶ï¼Œæ ¼å¼ï¼šèœå“åç§°,å¨å¸ˆ,ç‚¹èµæ•°,è¸©æ•°\nç„¶åé€‰æ‹©æ–‡ä»¶å¯¼å…¥ã€‚');
            document.getElementById('file-input-dishes').click();
        }

        function importChefs() {
            alert('æ‰¹é‡å¯¼å…¥åŠŸèƒ½ï¼š\nè¯·å‡†å¤‡CSVæ–‡ä»¶ï¼Œæ ¼å¼ï¼šå§“å,èŒä½,ç®€ä»‹,æ—¥æ¦œ,æœˆæ¦œ,æœˆç¥¨\nç„¶åé€‰æ‹©æ–‡ä»¶å¯¼å…¥ã€‚');
            document.getElementById('file-input-chefs').click();
        }

        // é‡ç½®å¯†é’¥
        function resetToken() {
            if (confirm('ç¡®å®šè¦é‡ç½®è®¿é—®å¯†é’¥å—ï¼Ÿ')) {
                localStorage.removeItem('admin_token');
                location.reload();
            }
        }

        // æ˜¾ç¤ºæç¤º
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast ' + type;
            toast.style.display = 'block';
            setTimeout(() => {
                toast.style.display = 'none';
            }, 3000);
        }

        // åˆå§‹åŒ–
        // --- æ™ºèƒ½å¯¼å…¥åŠŸèƒ½ (ç©ºæ ¼/è¡¨æƒ…ä¿®å¤ç‰ˆ) ---
        function openSmartImport() {
            document.getElementById('smart-import-modal').style.display = 'flex';
            document.getElementById('import-text').value = '';
            document.getElementById('import-preview').style.display = 'none';
        }
        
        let parsedDishes = [];
        
        // æ ¸å¿ƒå…¥å£å‡½æ•°
        function parseMenuText() {
            const text = document.getElementById('import-text').value;
            if (!text.trim()) { showToast('è¯·å…ˆç²˜è´´æ–‡æœ¬', 'error'); return; }
        
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            parsedDishes = [];
        
            // --- 1. è¯†åˆ«é¤æ®µä¸æ—¥æœŸ ---
            const now = new Date();
            const dateStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
            let mealType = 'åˆé¤'; // é»˜è®¤
            
            // æ‰«æå‰10è¡Œæ‰¾å…³é”®è¯
            const headerText = lines.slice(0, 10).join(' ');
            if (headerText.includes('æ—©é¤')) mealType = 'æ—©é¤';
            else if (headerText.includes('æ™šé¤')) mealType = 'æ™šé¤';
            else if (headerText.includes('å¤œå®µ')) mealType = 'å¤œå®µ';
            else if (headerText.includes('åˆé¤')) mealType = 'åˆé¤';
            else {
                // æ—¶é—´å…œåº•
                const h = now.getHours();
                if (h < 10) mealType = 'æ—©é¤';
                else if (h > 19) mealType = 'å¤œå®µ';
                else if (h > 14) mealType = 'æ™šé¤';
            }
        
            // è‡ªåŠ¨æ›´æ–°é…ç½®
            const newDateLocation = `${dateStr} ${mealType}`;
            console.log(`ğŸ“… è¯†åˆ«æ¨¡å¼: [${mealType}]`);
            const dateInput = document.getElementById('config-date');
            const autoCheck = document.getElementById('config-auto-date');
            if (dateInput && autoCheck) {
                dateInput.value = newDateLocation;
                autoCheck.checked = false;
                showToast(`å·²åˆ‡æ¢ä¸º: ${mealType}æ¨¡å¼`);
            }
        
            // --- 2. åˆ†æµå¤„ç† ---
            if (mealType === 'æ—©é¤') {
                parseBreakfastMode(lines);
            } else if (mealType === 'å¤œå®µ') {
                parseNightSnackMode(lines);
            } else {
                parseLunchDinnerMode(lines); // åˆé¤å’Œæ™šé¤ç»“æ„ç›¸ä¼¼
            }
        
            renderPreview();
        }
        
        // ==========================================
        // æ¨¡å¼ A: æ—©é¤è§£æå¼•æ“
        // ==========================================
        function parseBreakfastMode(lines) {
            let mainChef = 'æ—©é¤å¨å¸ˆ';
            
            lines.forEach(line => {
                if (line.includes('å¨å¸ˆ') || line.includes('ä¸»å¨')) {
                    const parts = line.replace(/[:ï¼š]/g, ':').split(':');
                    if (parts[1]) {
                        const name = parts[1].replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, '').trim(); 
                        if (isValidName(name)) mainChef = name;
                    }
                }
            });
        
            const ignoreHeaders = ['ä¸­å¼æ—©é¤', 'è¥¿ç‚¹', 'é¥®å“', 'æ°´æœ', 'æ¬¢è¿æ‚¨', 'SVé¤å…'];
            
            lines.forEach(line => {
                if (line.includes('å¨å¸ˆ') || line.includes('ä¸»å¨')) return;
                
                // æ¸…æ´—æ–‡æœ¬: ç§»é™¤ [xxx] å’Œ emoji
                let clean = line.replace(/\[.*?\]/g, '') // ç§»é™¤ [åº†ç¥] [ç«ç‘°] ç­‰
                                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, '') 
                                .replace(/[ğŸ³ğŸ¥˜ğŸŸğŸ”ğŸ“ğŸ¦ğŸœğŸ‰ğŸ¥¬ğŸğŸ¥ğŸ•ğŸ¥¦ğŸŒ½ğŸ¥›ğŸ¥šğŸ¥¤]/g, '')
                                .trim();
        
                if (clean.length < 2) return;
                if (ignoreHeaders.some(h => clean.includes(h))) return;
                if (clean.includes('å¤ªé˜³') || clean.includes('ç¥å¤§å®¶')) return;
        
                const items = clean.split(/[\s\/]+/); 
                items.forEach(item => {
                    if (item.length > 1 && !/\d/.test(item)) {
                        parsedDishes.push({ name: item, chef: mainChef });
                    }
                });
            });
        }
        
        // ==========================================
        // æ¨¡å¼ B: å¤œå®µè§£æå¼•æ“
        // ==========================================
        function parseNightSnackMode(lines) {
            let currentPrefix = 'ä¸­å¼';
        
            lines.forEach(line => {
                let clean = line.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, '')
                                .replace(/[\*\ğŸŒ¸]/g, '').trim();
        
                if (clean.length < 2) return;
                if (clean.includes('ç¥å¤§å®¶') || clean.includes('æ¬¢è¿')) return;
        
                if (clean.includes('ä¸­é¤') || clean.includes('ä»Šæ—¥èœå•')) {
                    currentPrefix = 'ä¸­å¼';
                    return;
                }
                if (clean.includes('æœ¬åœ°') || clean.includes('åŸƒåŠ')) {
                    currentPrefix = 'æœ¬åœ°';
                    return;
                }
        
                clean = clean.replace(/[ğŸ”ğŸŸğŸ¥¬ğŸªğŸğŸ ğŸ§ƒğŸ¥š]/g, '').trim();
                clean = clean.replace(/(ä¸€ä»½|ä¸€ç›’|ä¸€åª|ä¸€ä¸ª)/g, '');
        
                if (clean.length > 1) {
                    parsedDishes.push({ 
                        name: clean, 
                        chef: currentPrefix === 'æœ¬åœ°' ? 'æœ¬åœ°é£å‘³' : 'ä¸­å¼å¤œå®µ' 
                    });
                }
            });
        }
        
        // ==========================================
        // æ¨¡å¼ C: åˆé¤/æ™šé¤è§£æå¼•æ“ (ä¿®å¤ç©ºæ ¼å’Œè¡¨æƒ…)
        // ==========================================
        function parseLunchDinnerMode(lines) {
            // 1. é¢„æ‰«æå¨å¸ˆ
            let mainChefs = [];
            let noodleChef = '';       
            let grillChef = '';
            const allChefNames = new Set(); 
        
            lines.forEach(line => {
                const clean = line.replace(/[:ï¼š]/g, ':').trim();
                if (clean.includes('ä¸»å¨') && !clean.includes('å‰¯å¨') && !clean.includes('é¢æ¡£')) {
                    const content = clean.split(':')[1];
                    if (content) content.trim().split(/\s+/).forEach(name => {
                        if (isValidName(name)) { mainChefs.push(name); allChefNames.add(name); }
                    });
                }
                if (clean.includes('å‰¯å¨')) {
                    (clean.split(':')[1]||clean).trim().split(/\s+/).forEach(n => { if(isValidName(n)) allChefNames.add(n); });
                }
                if (clean.includes('é¢æ¡£')) {
                    const names = (clean.split(':')[1]||'').trim().split(/\s+/);
                    if (isValidName(names[0])) { noodleChef = names[0]; allChefNames.add(names[0]); }
                }
            });
        
            const mainChefsString = mainChefs.length > 0 ? mainChefs.join(' ') : 'å½“æ—¥å¨å¸ˆ';
            if (!noodleChef) noodleChef = mainChefs[0] || 'é¢æ¡£å¸ˆå‚…';
            if (!grillChef) grillChef = mainChefsString; 
        
            // 2. çŠ¶æ€æœºè§£æ
            let currentCategory = 'unknown'; 
            let currentChef = mainChefsString;
            
            // å…è®¸å¸¦ç©ºæ ¼çš„åŒ¹é…ï¼Œä¾‹å¦‚ "æ˜ æ¡£" -> åŒ¹é… "æ˜æ¡£"
            const validCategories = {
                'è¤èœ': mainChefsString,
                'ç´ èœ': mainChefsString,
                'ç²—ç²®': mainChefsString,
                'æ±¤ç±»': mainChefsString,
                'æ˜æ¡£': grillChef,      
                'ç‰¹è‰²æ¡£': grillChef,    
                'é¢é£Ÿ': noodleChef,
                'é¢æ¡£': noodleChef
            };
        
            const ignoreCategories = ['é²œæ¦¨æœæ±', 'æœæ±', 'ä¸»é£Ÿ', 'æ¸©é¦¨æç¤º', 'å……å€¼', 'å°èœ'];
            const stopKeywords = ['ç¥å¤§å®¶ç”¨é¤æ„‰å¿«', 'æ¬¢è¿å¤§å®¶', 'æ¸©é¦¨æç¤º'];
        
            let stopParsing = false;
        
            lines.forEach(line => {
                if (stopParsing) return;
                let cleanLine = line.trim();
                if (!cleanLine) return;
        
                if (stopKeywords.some(kw => cleanLine.includes(kw))) {
                    stopParsing = true;
                    return;
                }
        
                // å…³é”®ä¿®å¤ 1: ç”Ÿæˆæ— ç©ºæ ¼ã€æ— ç¬¦å·çš„æ ‡é¢˜ç”¨äºåŒ¹é…
                // "   æ˜   æ¡£ :" -> "æ˜æ¡£"
                let headerText = cleanLine.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, '')
                                          .replace(/[ğŸ½ğŸ¥™ğŸ ğŸ¥£ğŸœ]/g, '')
                                          .replace(/[:ï¼š]/g, '')
                                          .replace(/\s+/g, '') // ç§»é™¤æ‰€æœ‰ç©ºæ ¼
                                          .trim();
                
                // æ£€æŸ¥å¿½ç•¥
                for (const badCat of ignoreCategories) {
                    if (headerText.startsWith(badCat)) { currentCategory = 'ignore'; return; }
                }
        
                // æ£€æŸ¥æœ‰æ•ˆåˆ†ç±»
                for (const cat in validCategories) {
                    if (headerText.startsWith(cat)) {
                        currentCategory = 'active';
                        currentChef = validCategories[cat];
                        
                        // å…³é”®ä¿®å¤ 3: å¤„ç†åŒä¸€è¡Œçš„å†…å®¹ï¼Œå¹¶åœ¨åˆ†ç±»æ£€æµ‹é€šè¿‡åï¼Œç§»é™¤åˆ†ç±»å‰ç¼€
                        // "æ˜ æ¡£: é…¸èœç‰›è‚‰åŒ…" -> è¯†åˆ«ä¸º æ˜æ¡£ -> æå– "é…¸èœç‰›è‚‰åŒ…"
                        if (cleanLine.includes(':') || cleanLine.includes('ï¼š')) {
                            const parts = cleanLine.split(/[:ï¼š]/);
                            if (parts[1]) cleanLine = parts[1]; // å–å†’å·åçš„å†…å®¹ä½œä¸ºèœå“
                            else return;
                        } else {
                            return; // çº¯æ ‡é¢˜è¡Œï¼Œè·³è¿‡
                        }
                        break; 
                    }
                }
        
                if (currentCategory === 'unknown' || currentCategory === 'ignore') return;
        
                // å…³é”®ä¿®å¤ 2: æ¸…æ´—å†…å®¹ï¼Œç§»é™¤ [ç«ç‘°] ç­‰
                cleanLine = cleanLine.replace(/\[.*?\]/g, '') // ç§»é™¤æ‰€æœ‰ä¸­æ‹¬å·å†…å®¹
                                     .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, '') // Emoji
                                     .replace(/[\[\]ğŸ®ğŸŸğŸ”ğŸ¥©ğŸ¥’ğŸ†ğŸ¥¬ğŸğŸ¥‘ğŸ§‹ğŸ¦ğŸ‚ğŸƒğŸ«“]/g, '') // é£Ÿæå›¾æ ‡
                                     .replace(/^[:ï¼š]/, '') // ç§»é™¤è¡Œé¦–å¯èƒ½æ®‹ç•™çš„å†’å·
                                     .trim();
        
                if (cleanLine.includes('æœˆäº®') || cleanLine.includes('å¤ªé˜³') || cleanLine.length < 2) return;
                if (allChefNames.has(cleanLine)) return;
        
                // åˆ†å‰² (æ”¯æŒé€—å·ã€ç©ºæ ¼)
                const items = cleanLine.split(/[\s,ï¼Œ]+/);
                items.forEach(item => {
                    if (item.length > 1 && !/\d/.test(item) && !item.includes('å¾®ä¿¡') && !allChefNames.has(item)) { 
                        parsedDishes.push({ name: item, chef: currentChef });
                    }
                });
            });
        }
        
        // è¾…åŠ©å‡½æ•°
        function isValidName(name) {
            return name && name.length > 1 && name.length < 5 && !/[\d\w]/.test(name);
        }
        
        function renderPreview() {
            const tbody = document.getElementById('preview-tbody');
            tbody.innerHTML = '';
            document.getElementById('preview-count').textContent = parsedDishes.length;
            
            if (parsedDishes.length === 0) {
                tbody.innerHTML = '<tr><td colspan="3" style="text-align:center; padding:20px; color:#999;">æœªè¯†åˆ«åˆ°æœ‰æ•ˆèœå“ï¼Œè¯·æ£€æŸ¥æ–‡æœ¬æ ¼å¼</td></tr>';
                document.getElementById('import-preview').style.display = 'block';
                return;
            }
        
            parsedDishes.forEach((dish, index) => {
                let chefStyle = '';
                if (dish.chef.includes(' ')) chefStyle = 'color:#0f6b48; font-weight:bold;'; // å¤šä¸»å¨
                else if (dish.chef.includes('é¢')) chefStyle = 'color:#e65100; font-weight:bold;'; // é¢æ¡£
                else if (dish.chef.includes('å¤œå®µ') || dish.chef.includes('æœ¬åœ°')) chefStyle = 'color:#667eea; font-weight:bold;'; // å¤œå®µ
        
                tbody.innerHTML += `
                    <tr style="border-bottom:1px solid #eee;">
                        <td style="padding:8px;">
                            <input type="text" value="${dish.name}" class="table-input" onchange="parsedDishes[${index}].name = this.value">
                        </td>
                        <td style="padding:8px;">
                            <input type="text" value="${dish.chef}" class="table-input" style="${chefStyle}" onchange="parsedDishes[${index}].chef = this.value">
                        </td>
                        <td style="padding:8px; text-align:center;">
                            <button class="btn btn-danger" style="padding:2px 6px; font-size:12px;" onclick="removeParsedDish(${index})">Ã—</button>
                        </td>
                    </tr>
                `;
            });
            document.getElementById('import-preview').style.display = 'block';
        }
        
        function removeParsedDish(index) {
            parsedDishes.splice(index, 1);
            renderPreview();
        }
        
        async function executeImport() {
            if (parsedDishes.length === 0) return;
            if (!confirm(`âš ï¸ é«˜èƒ½é¢„è­¦ï¼š\n\nå³å°†æ¸…ç©ºã€æ‰€æœ‰æ—§èœå“ã€‘å¹¶å¯¼å…¥ ${parsedDishes.length} é“æ–°èœå“ã€‚\nåŒæ—¶æ›´æ–°æ—¥æœŸè®¾ç½®ã€‚\n\nç¡®å®šè¦æ‰§è¡Œå—ï¼Ÿ`)) return;
            
            // 1. ä¿å­˜æ—¥æœŸé…ç½®
            try { await saveConfig(); } catch (e) {}
        
            // 2. æ¸…ç©ºæ—§èœå“
            let existingIds = [];
            try {
                const res = await fetch('/api/admin/dishes', { headers: getHeaders() });
                const data = await res.json();
                existingIds = data.dishes.map(d => d.id);
            } catch (e) { return; }
        
            for (const id of existingIds) {
                try { await fetch(`/api/admin/dishes/${id}`, { method: 'DELETE', headers: getHeaders() }); } catch (e) {}
            }
        
            // 3. å¯¼å…¥æ–°èœå“
            let count = 0;
            for (const dish of parsedDishes) {
                try {
                    await fetch('/api/admin/dishes', {
                        method: 'POST',
                        headers: getHeaders(),
                        body: JSON.stringify({ name: dish.name, chef: dish.chef, up_votes: 0, down_votes: 0 })
                    });
                    count++;
                } catch (e) {}
            }
            
            showToast(`â™»ï¸ èœå•æ›´æ–°å®Œæˆï¼å·²å¯¼å…¥ ${count} é“èœ`, 'success');
            document.getElementById('smart-import-modal').style.display = 'none';
            loadDishes(); 
            loadConfig(); 
        }
        // --- æ™ºèƒ½å¯¼å…¥åŠŸèƒ½ (å¢å¼ºç‰ˆ) ---END
        
        init();
    </script>
</body>
</html>
